<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Cluster.html">Cluster</a><ul class='methods'><li data-type='method'><a href="Cluster.html#clusterify">clusterify</a></li></ul></li><li><a href="Mass.html">Mass</a><ul class='methods'><li data-type='method'><a href="Mass.html#probe">probe</a></li><li data-type='method'><a href="Mass.html#probeRequestToCoords">probeRequestToCoords</a></li><li data-type='method'><a href="Mass.html#serialize">serialize</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-3d-adjacency.html">3d-adjacency</a><ul class='methods'><li data-type='method'><a href="module-3d-adjacency.html#~find">find</a></li><li data-type='method'><a href="module-3d-adjacency.html#~nodeSorter">nodeSorter</a></li><li data-type='method'><a href="module-3d-adjacency.html#~sort">sort</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * @module 3d-adjacency
 * @description this module outputs sets of cells of which
 * are adjacent to one another.  see `.find`
 */
const Cluster = require('./cluster')
const Mass = require('./mass')

/**
 * find contingent clusters in a 3d array. touching entities
 * with truthy values are considered `Mass`. a collection
 * of mass is a `Cluster`. entites are touching IFF they share
 * a face (that is, a piece of mass may at most have 6 adjacent
 * neighbors)
 * @param {array[][]} arr
 * @param {object} opts
 * @param {function} [opts.isAdjacent] custom function to decide whether cells
 *                                     are adjacent or not. defaults to `truthy`
 *                                     values === adjacent. fn gets cell value,
 *                                     and must return truthy value 
 * @returns {array} e.g. [ [{x:0,y:0,z:1}], [{x:3,y:3,z:3},{x:4,y:3,z:3}]]
 */
function find(arr, opts) {
  var opts = opts || {}
  var isAdjacent = opts.isAdjacent || ((v) => v)
  var knownMass = {} // { 000: 1, 001: 2 } ==> { address: value }
  var clusters = []
  var clust
  var value
  for (var x = 0; x &lt; arr.length; ++x) {
    for (var y = 0; y &lt; arr[0].length; ++y) {
      for (var z = 0; z &lt; arr[0][0].length; ++z) {
        value = arr[x][y][z]
        if (isAdjacent(value) &amp;&amp; !knownMass.hasOwnProperty(`${x}${y}${z}`)) {
          knownMass[`${x}${y}${z}`] = value
          clust = new Cluster({
            domain: arr,
            knownMass,
            root: new Mass({ domain: arr, x, y, z, value }),
          })
          clust.clusterify()
          clusters.push(clust.serialize())
        }
      }
    }
  }
  return clusters
}

const SORT_PROPS = ['x', 'y', 'z']

/**
 * sorts nodes. see `sort`
 * @param {object} ma { x, y, z } node
 * @param {object} mb { x, y, z } node
 * @returns {number} -1/0/1
 */
function nodeSorter(ma, mb) {
  let axis
  for (var n in SORT_PROPS) {
    axis = SORT_PROPS[n]
    if (ma[axis] &lt; mb[axis]) return -1
    if (ma[axis] > mb[axis]) return 1
  }
  // generally, 0 means we have two identically addressed
  // nodes. this is viably an error case, FYI!
  /* istanbul ignore next */
  return 0
}

/**
 * sort a cluster set, where x, y, z values rank
 * higher in the sort, respectively
 * @param {array[]} clusterSet array of clusters
 * @returns {array} sorted clusterSet
 */
function sort (clusterSet) {
  clusterSet = clusterSet.map(clust => clust.sort(nodeSorter))
  return clusterSet.sort((cla, clb) => {
    return nodeSorter(cla[0], clb[0])
  })
}

module.exports = {
	find,
  sort,
  nodeSorter,
	Cluster,
	Mass
}</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
